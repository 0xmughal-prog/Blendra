# DeFi Vault Exploits Analysis & Security Hardening

## Analysis of Recent Vault Exploits (2023-2024)

---

## 1. Exactly Protocol Exploit (August 2023)

### What Happened
- **Loss:** $7.3M
- **Attack Vector:** DebtManager peripheral contract vulnerability
- **Root Cause:** Incorrect access control on debt repayment function
- **Method:** Attacker could manipulate debt positions of other users

### Technical Details
```solidity
// VULNERABLE CODE (simplified)
function repayDebt(address user, uint256 amount) external {
    // Missing: require(msg.sender == user || authorized[msg.sender])
    debt[user] -= amount;
    // Transfer logic...
}
```

### Attack Flow
1. Attacker identifies unprotected debt repayment function
2. Calls function to "repay" others' debt without actually paying
3. Manipulates accounting to withdraw collateral
4. Drains protocol funds

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- All withdraw functions check `msg.sender == owner` or allowance
- No external debt management
- Proper access controls on all state-changing functions

‚ö†Ô∏è **Check:**
```solidity
// In our redeem function - VERIFY THIS:
if (msg.sender != owner) {
    uint256 allowed = allowance(owner, msg.sender);
    if (allowed != type(uint256).max) {
        _approve(owner, msg.sender, allowed - shares);
    }
}
```

### Action Items
- [ ] Audit all functions that modify user balances
- [ ] Ensure proper access controls on strategy managers
- [ ] Add reentrancy guards on deposit/withdraw

---

## 2. Yearn Finance yUSDT Exploit (April 2023)

### What Happened
- **Loss:** $11.6M
- **Attack Vector:** Price oracle manipulation
- **Root Cause:** Flashloan + misconfigured oracle
- **Method:** Manipulated price of underlying asset in vault

### Technical Details
```solidity
// VULNERABLE CODE
function totalAssets() public view returns (uint256) {
    // Uses spot price from DEX - DANGEROUS!
    uint256 price = dex.getSpotPrice(token);
    return balance * price / 1e18;
}
```

### Attack Flow
1. Take flashloan of 10M USDT
2. Swap to manipulate DEX price
3. Deposit into vault at inflated price
4. Withdraw at normal price
5. Repay flashloan, keep profit

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- Use Chainlink oracle (TWAP, not spot)
- Oracle has staleness checks (1 hour max)
- No DEX price reliance

‚ö†Ô∏è **Check:**
```solidity
// Our oracle implementation:
function getGBPUSDPrice() external view returns (uint256 price) {
    (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) =
        gbpUsdFeed.latestRoundData();

    if (answer <= 0) revert InvalidPrice();
    if (updatedAt == 0) revert InvalidPrice();
    if (answeredInRound < roundId) revert StalePrice();
    if (block.timestamp - updatedAt > maxPriceAge) revert StalePrice(); // ‚úÖ GOOD

    return uint256(answer);
}
```

### Action Items
- [x] Use Chainlink oracle (already implemented)
- [x] Add staleness checks (already implemented)
- [ ] Consider additional price sanity checks (max % change per block)

---

## 3. Sentiment Protocol Hack (April 2023)

### What Happened
- **Loss:** $1M
- **Attack Vector:** Read-only reentrancy
- **Root Cause:** Curve LP token price manipulation via reentrancy
- **Method:** Exploited Curve's remove_liquidity callback

### Technical Details
```solidity
// VULNERABLE PATTERN
function getBalance() external view returns (uint256) {
    // Calls external contract during "view" - DANGEROUS
    return curvePool.balanceOf(address(this)) * curvePool.get_virtual_price();
}

// Attack uses reentrancy during Curve withdrawal:
// 1. Start withdrawal from Curve
// 2. During callback, virtual_price is inflated
// 3. Vault reads inflated balance
// 4. Mint excess shares
```

### Attack Flow
1. Deposit into vault
2. Trigger Curve withdrawal which calls back to vault
3. During callback, vault reads inflated LP token price
4. Withdraw at inflated valuation
5. Profit from price discrepancy

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- Don't use LP tokens as collateral
- ERC4626 vaults (Morpho, Euler) are reentrancy-safe
- Use Chainlink oracle, not external contract calls

‚ö†Ô∏è **Check:**
```solidity
// Make sure all view functions are truly read-only
function totalAssets() public view override returns (uint256) {
    uint256 strategyAssets = activeStrategy.totalAssets(); // ‚ö†Ô∏è EXTERNAL CALL
    uint256 perpAssets = perpManager.getPositionValue();   // ‚ö†Ô∏è EXTERNAL CALL
    return strategyAssets + perpAssets;
}
```

### Action Items
- [ ] Add ReentrancyGuard to all state-changing functions
- [ ] Ensure strategy adapters use CEI pattern (Checks-Effects-Interactions)
- [ ] Consider view reentrancy protection on totalAssets()

---

## 4. Platypus Finance Exploit (February 2023)

### What Happened
- **Loss:** $8.5M
- **Attack Vector:** Flawed collateral calculation
- **Root Cause:** Solvency check used amount instead of value
- **Method:** Deposited low-value token, borrowed high-value tokens

### Technical Details
```solidity
// VULNERABLE CODE
function borrow(address token, uint256 amount) external {
    uint256 collateralAmount = collateral[msg.sender]; // Amount, not value!
    require(collateralAmount >= amount, "Insufficient collateral");
    // Should check: collateralValue >= borrowValue
}
```

### Attack Flow
1. Deposit 1M of worthless token as collateral
2. System checks amount (1M) vs borrow amount (1M)
3. Borrow 1M of valuable USDC
4. Never repay

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- No lending/borrowing mechanism
- No multi-asset collateral
- Single asset vault (USDC only)

‚ö†Ô∏è **Check:**
- Ensure perp collateral always valued correctly
- Verify allocation percentages enforced

### Action Items
- [x] Single asset only (USDC) - no multi-collateral risk
- [ ] Verify perp position valuation is accurate
- [ ] Add checks that allocations always sum to 100%

---

## 5. Euler Finance Hack (March 2023)

### What Happened
- **Loss:** $197M (largest 2023 exploit)
- **Attack Vector:** Donation attack on ERC4626 vault
- **Root Cause:** First depositor inflation attack
- **Method:** Manipulated share price via direct token transfer

### Technical Details
```solidity
// VULNERABLE PATTERN (ERC4626)
function deposit(uint256 assets, address receiver) public returns (uint256 shares) {
    shares = convertToShares(assets); // Division by totalSupply
    // If totalSupply is 0, shares = assets
    // If totalSupply is 1 and totalAssets is huge, shares rounds to 0!
}
```

### Attack Flow (First Depositor Attack)
1. Attacker deposits 1 wei (gets 1 share)
2. Attacker donates 10M USDC directly to vault (totalAssets inflates)
3. Share price = 10M / 1 = 10M per share
4. Victim deposits 20M USDC
5. Victim gets: 20M / 10M = 2 shares
6. Attacker redeems 1 share for 10M
7. Attacker profits ~10M, victim loses ~10M

### Lessons for Our Vault
‚ö†Ô∏è **WE ARE VULNERABLE!**

Our current ERC4626 implementation doesn't protect against this.

### Critical Fix Required
```solidity
// ADD THIS TO CONSTRUCTOR
constructor(...) {
    // Mint initial shares to address(0) to prevent first depositor attack
    _mint(address(0), 1000); // Lock 1000 shares forever
    // OR mint to treasury/multisig
}

// OR use virtual shares/assets:
function _convertToShares(uint256 assets, Math.Rounding rounding)
    internal
    view
    virtual
    returns (uint256)
{
    // Add virtual offset to prevent division manipulation
    uint256 supply = totalSupply() + 1;
    uint256 totalAssets = totalAssets() + 1;
    return assets.mulDiv(supply, totalAssets, rounding);
}
```

### Action Items
- [ ] **CRITICAL:** Implement first depositor attack protection
- [ ] Mint initial shares in constructor
- [ ] Add minimum deposit amount (e.g., 100 USDC)
- [ ] Test extensively with fuzz testing

---

## 6. Hundred Finance Hack (April 2022, lessons still relevant)

### What Happened
- **Loss:** $7M
- **Attack Vector:** Rounding errors in reward calculation
- **Root Cause:** Integer division truncation
- **Method:** Multiple small transactions to accumulate rounding errors

### Technical Details
```solidity
// VULNERABLE CODE
function calculateReward(uint256 shares) public view returns (uint256) {
    // Division rounds down
    uint256 rewardPerShare = totalRewards / totalShares; // e.g., 1000 / 3 = 333
    return shares * rewardPerShare; // Loses 1 per calculation
}
```

### Attack Flow
1. Make 1000 small deposits
2. Each deposit loses 1 wei to rounding
3. Accumulate "dust" in contract
4. Find way to claim accumulated dust
5. Repeat

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- Use OpenZeppelin ERC4626 (audited rounding)
- No complex reward calculations
- Standard share math

‚ö†Ô∏è **Check:**
- Verify rounding in preview functions
- Ensure rounding always favors vault

### Action Items
- [x] Use OpenZeppelin ERC4626 (already doing this)
- [ ] Add tests for rounding edge cases
- [ ] Verify preview functions match actual deposits

---

## 7. Rari Capital Fuse Pool Exploit (April 2022)

### What Happened
- **Loss:** $80M
- **Attack Vector:** Reentrancy in withdraw function
- **Root Cause:** External call before state update
- **Method:** Reenter during withdrawal to claim funds twice

### Technical Details
```solidity
// VULNERABLE CODE
function withdraw(uint256 amount) external {
    // WRONG ORDER - external call before state update
    token.transfer(msg.sender, amount); // ‚ùå External call first
    balance[msg.sender] -= amount;       // ‚ùå State update after
}

// CORRECT ORDER (CEI Pattern)
function withdraw(uint256 amount) external {
    balance[msg.sender] -= amount;       // ‚úÖ State update first
    token.transfer(msg.sender, amount);  // ‚úÖ External call last
}
```

### Attack Flow
1. Call withdraw()
2. In receive() callback, call withdraw() again
3. First call hasn't updated state yet
4. Second call sees same balance
5. Withdraw twice with one balance

### Lessons for Our Vault
‚úÖ **Mostly Safe Because:**
- Use SafeERC20 (reentrancy-safe transfers)
- Follow CEI pattern

‚ö†Ô∏è **Check Our Code:**
```solidity
// In redeem function - VERIFY ORDER:
function redeem(...) public returns (uint256 assets) {
    // 1. Check allowance ‚úÖ
    if (msg.sender != owner) {
        uint256 allowed = allowance(owner, msg.sender);
        _approve(owner, msg.sender, allowed - shares);
    }

    // 2. Calculate assets ‚úÖ
    assets = previewRedeem(shares);

    // 3. Burn shares ‚úÖ (state change first)
    _burn(owner, shares);

    // 4. Withdraw from strategies ‚ö†Ô∏è (external calls)
    uint256 yieldReceived = activeStrategy.withdraw(yieldWithdraw);
    uint256 perpReceived = perpManager.decreasePosition(perpWithdraw);

    // 5. Transfer to user ‚úÖ (external call last)
    IERC20(asset()).safeTransfer(receiver, totalReceived);
}
```

### Action Items
- [ ] Add ReentrancyGuard from OpenZeppelin
- [ ] Audit all functions for CEI pattern compliance
- [ ] Add reentrancy tests

---

## 8. Nomad Bridge Exploit (August 2022)

### What Happened
- **Loss:** $190M
- **Attack Vector:** Uninitialized proxy
- **Root Cause:** Trusted root set to 0x00 in upgrade
- **Method:** Any message validated as "trusted"

### Technical Details
```solidity
// VULNERABLE CODE
contract NomadBridge {
    bytes32 public trustedRoot;

    function initialize(bytes32 _trustedRoot) external {
        // Missing: require(trustedRoot == bytes32(0))
        trustedRoot = _trustedRoot;
    }

    function process(Message memory message) external {
        require(message.root == trustedRoot); // 0x00 == 0x00 = true!
    }
}
```

### Attack Flow
1. Notice trustedRoot is 0x00
2. Submit message with root 0x00
3. Message validates as "trusted"
4. Drain all funds

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- No bridge functionality
- No proxy pattern (yet)
- Simple, non-upgradeable contracts

‚ö†Ô∏è **If Adding Upgradeability:**
- Use UUPS or Transparent proxy pattern
- Proper initialization guards
- Test upgrades extensively

### Action Items
- [ ] If adding proxy: use OpenZeppelin UUPS with initializer guards
- [ ] Add initialized checks
- [ ] Multiple upgrade simulations before mainnet

---

## 9. Pickle Finance Exploit (November 2020, still relevant)

### What Happened
- **Loss:** $20M
- **Attack Vector:** Swap function manipulation in strategy
- **Root Cause:** Trusted external calls without validation
- **Method:** Malicious strategy contract swapping through attacker's contract

### Technical Details
```solidity
// VULNERABLE CODE
function swapTokens(address token0, address token1, uint256 amount) external {
    // No validation on token addresses!
    IERC20(token0).transfer(address(swapper), amount);
    swapper.swap(token0, token1); // Swapper is attacker's contract
}
```

### Attack Flow
1. Deploy malicious "swapper" contract
2. Convince protocol to use it
3. Swapper transfers tokens to attacker instead of swapping
4. Drain strategy funds

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- Use established protocols (Morpho, Euler)
- Whitelist strategies via approval system
- No arbitrary external calls

‚ö†Ô∏è **Strategy Adapter Risks:**
- Each strategy must be audited
- Whitelist only approved strategies
- Timelock on strategy changes

### Action Items
- [ ] Maintain strict strategy whitelist
- [ ] Audit each strategy adapter before approval
- [ ] Add strategy address validation in propose function

---

## 10. Beanstalk Governance Attack (April 2022)

### What Happened
- **Loss:** $182M
- **Attack Vector:** Governance takeover via flashloan
- **Root Cause:** Voting power based on borrowable assets
- **Method:** Flashloan ‚Üí vote ‚Üí pass malicious proposal ‚Üí steal funds

### Technical Details
```solidity
// VULNERABLE PATTERN
function propose(bytes calldata proposal) external {
    require(balanceOf(msg.sender) > minProposalBalance);
    // Missing: require(locked balance, not borrowable)
}

function vote(uint256 proposalId) external {
    uint256 votes = balanceOf(msg.sender); // Can flashloan these!
}
```

### Attack Flow
1. Take flashloan of governance tokens
2. Propose malicious BIP (Beanstalk Improvement Proposal)
3. Vote with flashloaned tokens
4. Pass proposal instantly
5. Execute: drain all funds to attacker
6. Repay flashloan

### Lessons for Our Vault
‚úÖ **We're Safe Because:**
- Owner-based governance (not token-based)
- Timelock on changes (24h)
- No flashloan-vulnerable voting

‚ö†Ô∏è **If Adding Governance:**
- Use time-weighted voting power
- Snapshot-based voting
- Longer timelocks (48h+)
- Multi-sig requirements

### Action Items
- [x] Use timelock for admin functions (24h implemented)
- [ ] Consider snapshot-based governance if adding DAO
- [ ] Multi-sig for owner role

---

## Summary of Attack Vectors

| Attack Type | Frequency | Our Risk | Mitigation Status |
|-------------|-----------|----------|-------------------|
| **First Depositor Attack** | High | üî¥ HIGH | ‚ùå NEEDS FIX |
| **Reentrancy** | High | üü° MEDIUM | ‚ö†Ô∏è ADD GUARD |
| **Access Control** | Medium | üü¢ LOW | ‚úÖ GOOD |
| **Oracle Manipulation** | Medium | üü¢ LOW | ‚úÖ GOOD |
| **Rounding Errors** | Medium | üü¢ LOW | ‚úÖ GOOD |
| **Read-only Reentrancy** | Low | üü° MEDIUM | ‚ö†Ô∏è CHECK |
| **Price Manipulation** | Low | üü¢ LOW | ‚úÖ GOOD |
| **Governance Attack** | Low | üü¢ LOW | ‚úÖ GOOD |
| **Bridge Exploit** | N/A | N/A | N/A |
| **Strategy Manipulation** | Medium | üü° MEDIUM | ‚ö†Ô∏è WHITELIST |

---

## Critical Security Checklist

### üî¥ CRITICAL (Must Fix Before Mainnet)

- [ ] **First Depositor Attack Protection**
  ```solidity
  constructor(...) {
      _mint(address(0), 1000); // Lock initial shares
      // OR _mint(treasury, 1000);
  }
  ```

- [ ] **ReentrancyGuard on All State-Changing Functions**
  ```solidity
  import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

  contract GBPYieldVaultV2 is ERC4626, ReentrancyGuard {
      function deposit(...) public nonReentrant returns (uint256) { }
      function redeem(...) public nonReentrant returns (uint256) { }
  }
  ```

- [ ] **Minimum Deposit Amount**
  ```solidity
  uint256 public constant MIN_DEPOSIT = 100e6; // 100 USDC
  require(assets >= MIN_DEPOSIT, "Deposit too small");
  ```

### üü° HIGH PRIORITY (Add Soon)

- [ ] **Access Control Audit**
  - Verify all onlyOwner functions
  - Check allowance logic in redeem
  - Ensure strategy functions check msg.sender

- [ ] **Strategy Whitelist Validation**
  ```solidity
  mapping(address => bool) public approvedStrategies;

  function proposeStrategyChange(address newStrategy) external onlyOwner {
      require(approvedStrategies[newStrategy], "Strategy not approved");
  }
  ```

- [ ] **Price Sanity Checks**
  ```solidity
  uint256 public lastPrice;
  uint256 public constant MAX_PRICE_CHANGE = 1000; // 10%

  function getGBPUSDPrice() external view returns (uint256 price) {
      price = oracle.getPrice();
      if (lastPrice > 0) {
          uint256 change = abs(price - lastPrice) * 10000 / lastPrice;
          require(change <= MAX_PRICE_CHANGE, "Price change too large");
      }
  }
  ```

### üü¢ RECOMMENDED (Good to Have)

- [ ] **Emergency Pause Mechanism**
  ```solidity
  // Already implemented ‚úÖ
  function pause() external onlyOwner;
  ```

- [ ] **Timelock on Critical Operations**
  ```solidity
  // Already implemented for strategy changes ‚úÖ
  uint256 public constant STRATEGY_TIMELOCK = 24 hours;
  ```

- [ ] **Multi-sig Ownership**
  ```
  Use Gnosis Safe: 3-of-5 multisig
  ```

- [ ] **Monitoring & Alerts**
  - Tenderly alerts
  - OpenZeppelin Defender
  - Custom monitoring

---

## Security Testing Checklist

### Unit Tests
- [ ] First depositor attack test
- [ ] Reentrancy attack test
- [ ] Rounding error edge cases
- [ ] Access control tests
- [ ] Oracle staleness tests
- [ ] Strategy migration tests

### Integration Tests
- [ ] Full deposit ‚Üí withdraw cycle
- [ ] Strategy swapping
- [ ] Emergency scenarios
- [ ] Multi-user interactions

### Fuzz Tests
- [ ] Random deposit/withdraw amounts
- [ ] Random timing attacks
- [ ] Edge case amounts (0, max uint)

### Scenario Tests
- [ ] Strategy failure
- [ ] Oracle failure
- [ ] Perp liquidation
- [ ] Governance attack attempts

---

## Immediate Action Plan

### Phase 1: Critical Fixes (Before Testnet)
1. ‚úÖ Add first depositor protection
2. ‚úÖ Add ReentrancyGuard
3. ‚úÖ Add minimum deposit check
4. ‚úÖ Audit access controls

### Phase 2: Deployment (Testnet)
1. Deploy hardened contracts
2. Test all attack vectors
3. Fuzz test for 48 hours
4. Bug bounty on testnet

### Phase 3: Audit (Before Mainnet)
1. Professional audit (Trail of Bits / OpenZeppelin)
2. Formal verification
3. Economic audit
4. Fix all findings

### Phase 4: Mainnet Launch
1. Deploy with multisig
2. Gradual caps (100k ‚Üí 1M ‚Üí 10M)
3. Monitoring setup
4. Emergency procedures documented

---

## Next: Let's Fix and Deploy!

I'll now:
1. ‚úÖ Create hardened version of GBPYieldVaultV2
2. ‚úÖ Add all critical security fixes
3. ‚úÖ Deploy to Arbitrum Sepolia testnet
4. ‚úÖ Run security tests

Ready to proceed? üõ°Ô∏è
